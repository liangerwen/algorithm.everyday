# 解法-双重for循环

## Java实现

直接看代码，这里给出Java的实现：

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        // 第一轮遍历
        for (int i = 0; i < nums.length; i++) {
            // 第二轮遍历不能重复计算了
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    // 注意leetcode原题中要求返回的是索引位置
                    return new int[]{i, j};
                }
            }
        }
        return null;
    }
}
```
> 时间复杂度O(N^2)，空间复杂度O(1)

上面这个双重for循环算法，先使用变量i遍历目标数组，然后对于每个元素，再追加遍历其位置至数组尾部的所有元素（因为之前的元素已经在i之前的遍历中比较过了），最终计算出相关位置。因为是双重for循环，所以很容易就可以计算出时间复杂度O(N^2)，空间复杂度O(1)

## 一个类似例子

![两数之和错例](./images/两数之和.jpg "两数之和错例")

上面这个图是我在一个前端群里看见的，图的作者原话是说自己的题解消耗有点大。稍微看一下代码，这个小老弟虽然只写了一层循环，乍一看代码还挺干净，但其实indexOf()方法本身也是一个遍历操作，所以在执行方面，这个其实还是一个双重for循环的做法，虽然本题非常简单，但是这个小老弟的写法还是提醒我们，在构建算法的时候，一定要小心局部的一些处理，很有可能随手一些，性能就打了折扣，尤其是构建一些复杂算法时，局部的细节处理一定要到位


